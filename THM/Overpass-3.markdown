---
title: "Overpass 3"
layout: default
---


# Enumeration

Some basic enumeration steps. I start with nmap.

`sudo nmap -sSCV 10.10.45.32 -v`

![20230225214145.png](/assets/images/20230225214145.png)

We see that port 80 is open, so I do some basic enumeration with nikto and directory enumeration. The nikto scan did not show us any useful information. The directory enumeration found a directory named backup and I was able to download the backup.zip file.

`nikto -h 10.10.45.32`

![20230225214155.png](/assets/images/20230225214155.png)

![20230225214204.png](/assets/images/20230225214204.png)

Once we download the file, we unzip it and find CustomerDetails.xlsx.gpg and priv.key in it.

![20230225214211.png](/assets/images/20230225214211.png)

I was unsure what priv.key was, so I check it using file to confirm that the priv.key is a gpg private key. That means I can use it to decrypt the CustomerDetails file. This file contains a list of usernames and passwords. We found an ftp server from our initial nmap scan, and I check if any of these usernames can connect to it. We get a hit and are able to connect!

![20230225214218.png](/assets/images/20230225214218.png)

![20230225214222.png](/assets/images/20230225214222.png)

![20230225214229.png](/assets/images/20230225214229.png)

![20230225214234.png](/assets/images/20230225214234.png)

The ftp server looks like it may be hosting the files for the website.

I create a malicious php file using [revshells](https://www.revshells.com/). I start the netcat listener, upload the file to the ftp server, and visit the page and get a callback!

![clip_image013.png](/assets/images/clip_image013.png)

![20230225214247.png](/assets/images/20230225214247.png)

After doing some manual enumeration without finding much I run linpeas to see if there is anything I missed. Linpeas finds us an interesting file in /etc/exports with the contents below.

/home/james *(rw,fsid=0,sync,no_root_squash,insecure)

The config file that controls this setting is /etc/exports and we can show this information by using showmount -e 127.0.0.1. 

This file is saying that there is an Network File Share (NFS) running on this machine. It is linked to the directory /home/james. The asterisk tells us there are no IP restrictions for who can mount the share. The other options that we are interested in are no_root_squash and insecure. No_root_squash means that anyone that mounts the share can create files as root on the target share/system. The last hurdle we need to get over is that the share is listening on localhost. The last flag Insecure tells us we can still use this exploit even though we will need to use some port forwarding.

At first I attempted to mount the share remotely, but there was an error No route to host.

At this point we change our user to paradox using the password we got earlier. This will allow us to use ssh port forwarding. We could stay on apache and use a tool like chisel, but ssh is more stable so I prefer to use it when possible.

Setup the port forwarding. We need two separate ports to allow us to mount the NFS share. The nfs port and the mountd port. We can find these ports by using rpcinfo -p.

![20230225214259.png](/assets/images/20230225214259.png)

We use ssh to do a local port forward to the target ports using paradoxâ€™s connection.

![20230225214306.png](/assets/images/20230225214306.png)

Now we can mount the share locally on our attacking machine, being sure to specify the ports we used in our port forwarding. Note you must also use tcp or else you will return with errors. -v is used to help with troubleshooting.

![20230225214312.png](/assets/images/20230225214312.png)

We can then move into the mounted directory and get the user flag.

![20230225214317.png](/assets/images/20230225214317.png)

We then need to setup a way to login as James, so we create a new ssh key, modify his authorized_keys in his .ssh directory, and connect using our new key.

Since the NFS drive is configured with no_root_squash, any command we run as root on our attacking machine is the same as running it as root from the vulnerable host. I copy the /bin/bash binary into the mounted directory and set the SUID bit. The reason we need to use a binary instead of a script is due to the limitations that SUID bits have with scripts. Even when scripts have a SUID bit set, they will not run as root.

![20230225214328.png](/assets/images/20230225214328.png)

When I attempted to run the command ./bash -p we get errors about GLIBC version not being found.

![clip_image023.png](/assets/images/clip_image023.png)

This happened because I copied my bash binary from my attacking machine which is compiled in a different version of GLIBC than what the compromised host has. My workaround was to use our session with james to copy the local /bin/bash binary from the target machine. Once the file is copied, I can edit the file using my mounted drive to enable the SUID bit, and to make sure it is owned by root.

![20230225214335.png](/assets/images/20230225214335.png)

Now when we run the binary on the james session we get a root shell!

![20230225214339.png](/assets/images/20230225214339.png)
